.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH QuickForm 3pm "perl 5.004, patch 04" "21/Oct/99" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
CGI::QuickForm \- Perl module to provide quick CGI forms. 
.SH "SYNOPSIS"
.PP
.Vb 1
\&    # Minimal example. (Insecure no error checking.) 
.Ve
.Vb 4
\&    #!/usr/bin/perl -w
\&    use strict ;
\&    use CGI qw( :standard :html3 ) ;
\&    use CGI::QuickForm ;
.Ve
.Vb 8
\&    show_form(
\&        -ACCEPT => \e&on_valid_form, # You must supply this subroutine.
\&        -TITLE  => 'Test Form',
\&        -FIELDS => [
\&            { -LABEL => 'Name', },  # Default field type is textfield.
\&            { -LABEL => 'Age',  },  # Stored in param( 'Age' ).
\&        ],
\&    ) ;
.Ve
.Vb 10
\&    sub on_valid_form {
\&        my $name = param( 'Name' ) ;
\&        my $age  = param( 'Age' ) ;
\&        open PEOPLE, ">>people.tab" ;
\&        print "$name\et$age\en" ;
\&        close PEOPLE ;
\&        print header, start_html( 'Test Form Acceptance' ),
\&            h3( 'Test Form Data Accepted' ),
\&            p( "Thank you $name for your data." ), end_html ;
\&    }
.Ve
.Vb 1
\&    # All QuickForm options
.Ve
.Vb 4
\&    #!/usr/bin/perl -w
\&    use strict ;
\&    use CGI qw( :standard :html3 ) ;
\&    use CGI::QuickForm ;
.Ve
.Vb 80
\&    show_form(
\&        -ACCEPT      => \e&on_valid_form, 
\&        -FOOTER      => undef,
\&        -HEADER      => undef,      
\&        -LANGUAGE    => 'en',
\&        -TITLE       => 'Test Form',
\&        -VALIDATE    => undef,       # Set this to validate the entire record
\&        -SIZE        => undef,
\&        -MAXLENGTH   => undef,
\&        -ROWS        => undef,
\&        -COLUMNS     => undef,
\&        -CHECK       => 1,
\&        -FIELDS      => [            
\&            { 
\&                -LABEL     => 'Name', 
\&                -REQUIRED  => undef,
\&                -TYPE      => 'textfield',
\&                -VALIDATE  => undef, # Set this to validate the field
\&                -CLEAN     => undef, # Set this to clean up valid data
\&                # Lowercase options are those supplied by CGI.pm
\&                -name      => undef, # Defaults to -LABEL's value.
\&                -default   => undef,
\&                -size      => 30,
\&                -maxlength => undef,
\&            },
\&            { 
\&                -LABEL     => 'Address', 
\&                -REQUIRED  => undef,
\&                -TYPE      => 'textarea',
\&                -VALIDATE  => undef,
\&                -CLEAN     => undef,
\&                -name      => undef,
\&                -default   => undef,
\&                -rows      => 3,
\&                -columns   => 40,
\&            },
\&            { 
\&                -LABEL     => 'Password', 
\&                -REQUIRED  => undef,
\&                -TYPE      => 'password_field',
\&                -VALIDATE  => undef,
\&                -CLEAN     => undef,
\&                -name      => undef,
\&                -value     => undef,
\&                -size      => 10,
\&                -maxlength => undef,
\&            },
\&            { 
\&                -LABEL     => 'Hair colour', 
\&                -REQUIRED  => undef,
\&                -TYPE      => 'scrolling_list',
\&                -VALIDATE  => undef,
\&                -CLEAN     => undef,
\&                -name      => undef,
\&                -values    => [ qw( Red Black Brown Grey White ) ],
\&                -size      => 1,
\&                -multiples => undef,
\&            },
\&            { 
\&                -LABEL     => 'Worst Sport', 
\&                -REQUIRED  => undef,
\&                -TYPE      => 'radio_group',
\&                -VALIDATE  => undef,
\&                -CLEAN     => undef, 
\&                -name      => undef,
\&                -values    => [ qw( Boxing Cricket Golf ) ], 
\&                -default   => 'Golf',
\&                -size      => undef,
\&                -multiples => undef,
\&            },
\&            # Any other CGI.pm field can be used in the same way.
\&        ],
\&        -BUTTONS    => [
\&            { -name => 'Add'    },
\&            { -name => 'Edit'   },
\&            { -name => 'List'   },
\&            { -name => 'Remove' },
\&        ],
\&    ) ;
\& 
.Ve
.SH "DESCRIPTION"
\f(CWshow_form\fR, provides a quick and simple mechanism for providing on-line CGI
forms.
.PP
When \f(CWshow_form\fR executes it presents the form with the fields requested.
As you can see from the minimal example at the beginning of the synopsis it
will default everything it possibly can to get you up and running as quickly
as possible.
.PP
If you have specified any validation it will validate when the user presses
the submit button. If there is an error it will re-present the form with the
erroneous fields marked and with all the data entered in tact. This is
repeated as often as needed. Once the user has corrected all errors and the
data is valid then your \f(CW&on_valid_form\fR subroutine will be called so that
you can process the valid data in any way you wish.
.Sh "QuickForm form-level (record-level) options"
\f(CW-ACCEPT\fR Required subroutine reference. This is a reference to the
subroutine to execute when the form is successfully completed, i.e. once all
the fields and the whole record are valid (either because no validation was
requested or because every validation subroutine called returned true). The
parameters are accessible via \f(CWCGI.pm\fR, so your \f(CW&on_valid_form\fR may look
something like this:
.PP
.Vb 4
\&    sub on_valid_form {
\&        my $first_param  = param( 'first' ) ;
\&        my $second_param = param( 'second' ) ;
\&        my $third_param  = param( 'third' ) ;
.Ve
.Vb 3
\&        # Process, e.g. send an email or write a record to a file or database.
\&        # Give the user a thank you.
\&    }
.Ve
\f(CW-BUTTONS\fR Optional array reference. This is an array of submit buttons. The
buttons appear at the bottom of the form, after all the fields. Each button is
defined as an anonymous hash, e.g.
.PP
.Vb 4
\&    -BUTTONS    => [
\&        { -name => 'New'    },
\&        { -name => 'Update' },
\&        ],
.Ve
although any other legitimate \f(CWCGI.pm\fR options may also be given, e.g.
.PP
.Vb 4
\&    -BUTTONS    => [
\&        { -name => 'New',   -value => 'BUTTON_NEW'    },
\&        { -name => 'Update' -value => 'BUTTON_UPDATE' },
\&        ],
.Ve
If no \f(CW-BUTTONS\fR option array reference is given it will be created with
\f(CW{ -name =< 'Submit' }\fR by default. Note that this option replaces the
\f(CW-BUTTONLABEL\fR option. If \f(CW-BUTTONLABEL\fR is used it will be converted into
the new form automatically so old scripts will \fInot\fR be broken. However use
of \f(CW-BUTTONS\fR is recommended for all new work.
.PP
\f(CW-CHECK\fR Optional boolean, default is true. When \f(CWshow_form\fR is called it
will check (i.e. do validation) providing there are parameters (i.e. the user
has filled in the form) \fIand\fR if \f(CW-CHECK\fR is true. This option would not
normally be used. However if you have links which call your form with some
parameters (e.g. default values), you will want the form to be displayed with
the defaults but \fIwithout\fR any validation taking place in the first instance.
In this situation you would set \f(CW-CHECK\fR to false. Thus we must cope with the
following scenarios: 
1. Form is called with no params \- must display blank form and validate when
the user presses a button;
2. Form is called with params (e.g. by clicking a link we've provided) \- must
display form with any defaults and \fInot\fR validate until the user presses a
button;
3. Form is called with params (as the result of the user pressing a button) \-
validation must take place.
.PP
To achieve the above we need to add an extra field=value pair to the \s-1URL\s0 we
provide and if that is present then skip validation. The field's name must
\fInot\fR be one of the form's fields! e.g.
.PP
.Vb 15
\&    # If it is to be called from one of our own URLs with something like
\&    # www.mysite.com/cgi-bin/myscript?colour=green&size=large
\&    # then we must add in the extra field=value and write the preceeding link
\&    # for example as:
\&    # www.mysite.com/cgi-bin/myscript?QFCHK=0&colour=green&size=large 
\&    # We then use query_string() to set -CHECK to 0 and show the form with the
\&    # defaults without validating - we'll validate when they press a button. 
\&    # If its been called as something like www.mysite.com/cgi-bin/myscript
\&    # then set -CHECK to 1 which gives us standard behaviour:
\&    # i.e. if there are params then show_form will validate; otherwise it will
\&    # show the blank form.
\&    show_form(
\&        -CHECK => ( query_string() =~ /QFCHK=0/o ? 0 : 1 ), 
\&        # etc
\&        ) ;
.Ve
.Vb 7
\&    # Or more verbosely:
\&    my $Check = 1 ;
\&    $Check    = 0 if query_string() =~ /QFCHK=0/o ; 
\&    show_form(
\&        -CHECK => $Check,
\&        # etc
\&        ) ;
.Ve
Note that QuickForm discards any query string if it reinvokes itself because
of invalid data. This is useful because it means you can use the query string
to distinguish between a \*(L'first time\*(R' call and subsequent calls as we do here
with \-\s-1CHECK\s0. However if you want a query string parameter to survive these
calls we must extract them and pass them ourselves, e.g. via a hidden field.
.PP
\f(CW-FOOTER\fR Optional string. This is used to present any text following the
form and if used it must include everything up to and including final
\*(L"</\s-1HTML\s0>\*(R", e.g.:
.PP
.Vb 2
\&    my $footer = p( "Thank's for your efforts." ) .
\&                 h6( "Copyright (c) 1999 Summer plc" ) . end_html ;
.Ve
.Vb 3
\&    show_form(
\&        -FOOTER => $footer,
\&        # etc
.Ve
\f(CW-HEADER\fR Optional string. This is used to present your own title and text
before the form proper. If you use this it must include everything from
\*(L"Content-type: text/html\*(R" onwards. For example:
.PP
.Vb 2
\&    my $header = header . start_html( "This is my Title" ) .
\&                 h2( "My new Form" ) . p( "Please answer the questions!" ) ;
.Ve
.Vb 3
\&    show_form(
\&        -HEADER => $header,
\&        # etc
.Ve
\f(CW-LANGUAGE\fR Optional string. This option accepts \*(L'en\*(R' (english), \*(L'de\*(R'
(german) and \*(L'fr\*(R' (french) \- the translations were done by Babelfish.
('english\*(R' is also supported for backward compatibility.) If people provide me
with translations I will add other languages. This is used for the
presentation of messages to the user, e.g.:
.PP
.Vb 3
\&    Please enter the information.
\&    Fields marked with + are required.
\&    Fields marked with * contain errors or are empty.
.Ve
\f(CW-TITLE\fR Required string (unless you use \f(CW-HEADER\fR). This is used as the
form's title and as a header on the form's page \- unless you use the
\f(CW-HEADER\fR option (see above) in which case this option is ignored.
.PP
\f(CW-VALIDATE\fR Optional subroutine reference. This routine is called after each
individual field has been validated. It is given the fields in a name=>value
hash. It should either return a simple true (valid) or false (invalid) or a
two element list, the first element being a true/false value and the second
value either an empty string or an (html) string which gives the reason why
the record is invalid.
Typically it may have this structure:
.PP
.Vb 11
\&    sub valid_record {
\&        my %field = @_ ;
\&        my $valid = 1 ;
\&        # Do some multi-field validation, e.g.
\&        if( $field{'colour'} eq 'blue' and
\&            $field{'make'} eq 'estate' ) {
\&            $valid = 0 ; # No blue estates available.
\&        }
\&        # etc.
\&        $valid ; # Return the valid variable which may now be false.
\&    }
.Ve
or now (preferred style):
.PP
.Vb 13
\&    sub valid_record {
\&        my %field = @_ ;
\&        my $valid = 1 ;
\&        my $why   = '' ;
\&        # Do some multi-field validation, e.g.
\&        if( $field{'colour'} eq 'blue' and
\&            $field{'make'} eq 'estate' ) {
\&          $valid = 0 ; # No blue estates available.
\&          $why   = '<B><I>No blue estates available</I></B>' ;
\&        }
\&        # etc.
\&        ( $valid, $why ) ; 
\&    }
.Ve
\fIBoth syntaxes work so no existing code need be changed.\fR If the record is
invalid the \f(CW$why\fR element will be shown near the top of the form just before
the fields themselves, otherwise (i.e. if the record is valid) it will be
ignored.
.PP
\f(CW-COLUMNS\fR Optional integer. If set then any \f(CW-TYPE => textarea\fR will
have a \f(CW-columns\fR set to this value unless an explicit \f(CW-columns\fR is given.
.PP
\f(CW-MAXLENGTH\fR Optional integer. If set then any \f(CW-TYPE => textfield\fR will
have a \f(CW-maxlength\fR set to this value unless an explicit \f(CW-maxlength\fR is given.
.PP
\f(CW-ROWS\fR Optional integer. If set then any \f(CW-TYPE => textarea\fR will
have a \f(CW-rows\fR set to this value unless an explicit \f(CW-rows\fR is given.
.PP
\f(CW-SIZE\fR Optional integer. If set then any \f(CW-TYPE => textfield\fR will
have a \f(CW-size\fR set to this value unless an explicit \f(CW-size\fR is given. For
example:
.PP
.Vb 11
\&     show_form(
\&        -ACCEPT => \e&on_valid_form, # You must supply this subroutine.
\&        -TITLE  => 'Test Form',
\&        -SIZE   => 50,
\&        -FIELDS => [
\&            { -LABEL => 'Name', },  
\&            { -LABEL => 'Age',  }, 
\&        ],
\&    ) ;
\&    # Both the fields will be textfields because that is the default and both
\&    # will have a -size of 50.
.Ve
.Vb 26
\&    show_form(
\&        -ACCEPT    => \e&on_valid_form, # You must supply this subroutine.
\&        -TITLE     => 'Test Form',
\&        -SIZE      => 50,
\&        -MAXLENGTH => 70,
\&        -FIELDS => [
\&            { 
\&                -LABEL => 'Name', 
\&                -CLEAN => \e&cleanup, # You must supply this (see later).
\&            },  
\&            { -LABEL => 'Age',  }, 
\&            { 
\&                -LABEL => 'Country',  
\&                          # Here we upper case the country.
\&                -CLEAN => sub { local $_ = shift ; tr/a-z/A-Z/ ; $_ }, 
\&                -size  => 20,
\&            }, 
\&        ],
\&    ) ;
\&    # All three fields will be textfields. Name and Age will have a -size of
\&    # 50 but Country will have a -size of 20. All three will have a -maxlength
\&    # of 70.
\& 
\&C<-FIELDS> Required array reference. This is an array of hashes; there must
\&be at least one. The fields are displayed in the order given. The options
\&available in each field hash are covered in the next section.
.Ve
.Sh "QuickForm field-level options"
\f(CW-CLEAN\fR Optional subroutine reference. If specified this subroutines will be
called for the relevant field if and only if the whole record is valid, i.e.
just before calling your \f(CWon_valid_form\fR subroutine. It will receive a single
parameter (the value of the relevant param), and must return a new value. A
typical routine might clean up excess whitespace, e.g.:
.PP
.Vb 2
\&    sub cleanup {
\&        local $_ = shift ; # This is the value of param( <fieldname> )
.Ve
.Vb 3
\&        tr/\et \en\er\ef/ /s ; # Convert multiple whitespace to one space.
\&        s/^\es*//o ;        # Remove leading whitespace.
\&        s/\es*$//o ;        # Remove trailing whitespace.
.Ve
.Vb 2
\&        $_ ;
\&    }
.Ve
\f(CW-LABEL\fR Required string. This is the display label for the field. It is
also used as the field's name if no \f(CW-name\fR option is used.
.PP
\f(CW-REQUIRED\fR Optional boolean. Default is false. If set to true the field
must contain something. Should only be used with text fields. It is ignored if
\f(CW-VALIDATE\fR is given since \f(CW-VALIDATE\fR overrides (see later).
.PP
\f(CW-TYPE\fR Optional string. Default is \f(CWtextfield\fR. May be any field supported
by \f(CWCGI.pm\fR.
.PP
\f(CW-VALIDATE\fR Optional subroutine reference. If specified this subroutine will
be called when the user presses the submit button; its argument will be the
value of the field. It should either return a simple true (valid) or false
(invalid) or a two element list, the first element being a true/false value
and the second value either an empty string or an (html) string which gives
the reason why the field is invalid.
Its typical structure may be:
.PP
.Vb 6
\&    sub valid_national_insurance {
\&        my $ni = shift ;
\&    
\&        $ni = uc $ni ;
\&        ( $ni =~ /^[A-Z]{2}\ed{7}[A-Z]$/o ) ? 1 : 0 ;
\&    }
.Ve
or now (preferred style):
.PP
.Vb 7
\&    sub valid_national_insurance {
\&        my $ni  = shift ;
\&        my $why = '<I>Should be 2 letters followed by 7 ' .
\&                  'digits then a letter</I>' ;
\&    
\&        $ni = uc $ni ;
\&        my $valid = ( $ni =~ /^[A-Z]{2}\ed{7}[A-Z]$/o ) ? 1 : 0 ;
.Ve
.Vb 2
\&        ( $valid, $why ) ; 
\&    }
.Ve
\fIBoth syntaxes work so no existing code need be changed.\fR If the field is
invalid the \f(CW$why\fR element will be shown immediately to the right of the
field it refers to, otherwise (i.e. if the field is valid) it will be ignored.
.Sh "\s-1CGI\s0.pm field-level options"
All the other options passed in the hash should be the lowercase options
supported by \f(CWCGI.pm\fR for the particular field type. For example for a
\f(CW-TYPE\fR of \f(CWtextfield\fR the options currently supported are \f(CW-name\fR,
\f(CW-default\fR, \f(CW-size\fR and \f(CW-maxlength\fR; you may use any, all or none of them
since \f(CWCGI.pm\fR always provides sensible defaults. See \*(L"All QuickForm options\*(R"
in the \s-1SYNOPSIS\s0 above for examples of the most common field types.
.Sh "\s-1EXAMPLE\s0 #1: Using a form to generate email "
This program is provided as an example of QuickForm's capabilities, it is not a
production-quality program: it has no error checking and is \fInot\fR secure.
.PP
.Vb 4
\&    #!/usr/bin/perl -w
\&    use strict ;
\&    use CGI qw( :standard :html3 ) ;
\&    use CGI::QuickForm ;
.Ve
.Vb 20
\&    show_form(
\&        -TITLE  => 'Test Form',
\&        -ACCEPT => \e&on_valid_form, 
\&        -FIELDS => [
\&            {
\&                -LABEL    => 'Forename',
\&                -REQUIRED => 1,
\&            },
\&            {
\&                -LABEL    => 'Surname',
\&                -REQUIRED => 1,
\&            },
\&            { -LABEL => 'Age', },
\&            {
\&                -LABEL    => 'Sex',
\&                -TYPE     => 'radio_group',
\&                '-values' => [ qw( Female Male ) ],
\&            },
\&        ],
\&    ) ;
.Ve
.Vb 16
\&    # This subroutine will only be called if the name fields contain at
\&    # least one character.
\&    sub on_valid_form {
\&        my $forename = param( 'Forename' ) ;
\&        my $surname  = param( 'Surname' ) ;
\&        my $age      = param( 'Age' ) ;
\&        open MAIL, "|/usr/lib/sendmail -t" ; 
\&        print MAIL "From: test\e@localhost\en" .
\&                   "To: user\e@localhost\en" .
\&                   "Subject: Quick Form Email Test\en\en" .
\&                   "Name: $forename $surname\en" .
\&                   "Age:  $age\en" ;
\&        print header, start_html( 'Test Form Data Accepted' ),
\&            h3( 'Test Form Data Accepted' ),
\&            p( "Thank you $forename for your data." ), end_html ;
\&    }
.Ve
.Sh "\s-1EXAMPLE\s0 #2: Appending data to a file"
This program is provided as an example of QuickForm's capabilities, it is not a
production-quality program: it has no error checking and is \fInot\fR secure.
.PP
.Vb 1
\&    #!/usr/bin/perl -w
.Ve
.Vb 3
\&    use strict ;
\&    use CGI qw( :standard :html3 ) ;
\&    use CGI::QuickForm ;
.Ve
.Vb 27
\&    show_form(
\&        -TITLE     => 'Test Form',
\&        -ACCEPT    => \e&on_valid_form, 
\&        -VALIDATE  => \e&valid_form,
\&        -SIZE      => 40,
\&        -MAXLENGTH => 60,
\&        -FIELDS => [
\&            {
\&                -LABEL     => 'Forename',
\&                -VALIDATE  => \e&valid_name,
\&                -CLEAN     => \e&cleanup,    # (See earlier for definition.)
\&            },
\&            {
\&                -LABEL     => 'Surname',
\&                -VALIDATE  => \e&valid_name,
\&                -CLEAN     => \e&cleanup,    # (See earlier for definition.)
\&            },
\&            {
\&                -LABEL     => 'Age',
\&                # &mk_valid_number generates a subroutine (a closure) and
\&                # returns a reference to that subroutine.
\&                -VALIDATE  => &mk_valid_number( 3, 130 ), 
\&                -size      => 10,
\&                -maxlength => 3,
\&            },
\&        ],
\&    ) ;
.Ve
.Vb 12
\&    # This will only be called if all the validation routines return true. 
\&    sub on_valid_form {
\&        my $forename = param( 'Forename' ) ;
\&        my $surname  = param( 'Surname' ) ;
\&        my $age      = param( 'Age' ) ;
\&        open FILE, ">>namedata.tab" ;
\&        print FILE "$surname\et$forename\et$age\en" ;
\&        close FILE ;
\&        print header, start_html( 'Test Form Data Accepted' ),
\&            h3( 'Test Form Data Accepted' ),
\&            p( "Thank you $forename for your data." ), end_html ;
\&    }
.Ve
.Vb 11
\&    # This is called to validate the entire form (record).
\&    # Use a routine like this if there are relationships between fields that
\&    # must be tested.
\&    sub valid_form {
\&        my %rec   = @_ ;
\&        my $valid = 1 ;
\&        # We don't allow (perfectly valid!) names like 'John John'.
\&        my $why   = 'Not allowed to have identical forename and surname' ;
\&        $valid    = 0 if lc $surname eq lc $forename ;
\&        ( $valid, $why ) ; # $why is ignored if valid.
\&    }
.Ve
.Vb 6
\&    sub valid_name {
\&        my $name  = shift ;
\&        my $valid = 1 ;
\&        $valid    = 0 if $name !~ /^\ew{2,}$/o ;
\&        ( $valid, 'Name must have at least 2 letters' ) ; 
\&    }
.Ve
.Vb 2
\&    sub mk_valid_number {
\&        my( $min, $max ) = @_ ;
.Ve
.Vb 5
\&        sub { 
\&            my $valid = $_[0] ? ( $min <= $_[0] and $_[0] <= $max ) : 1 ;
\&            ( $valid, "<I>Should be between $min and $max inclusive</I>" ) ; 
\&        } ;
\&    }
.Ve
.SH "BUGS"
None that have come to light (yet).
.SH "AUTHOR"
Mark Summerfield. I can be contacted as <summer@chest.ac.uk> \-
please include the word \*(L'quickform\*(R' in the subject line.
.SH "COPYRIGHT"
Copyright (c) Mark Summerfield 1999. All Rights Reserved.
.PP
This module may be used/distributed/modified under the LGPL.

.rn }` ''
.IX Title "QuickForm 3pm"
.IX Name "CGI::QuickForm - Perl module to provide quick CGI forms."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "QuickForm form-level (record-level) options"

.IX Subsection "QuickForm field-level options"

.IX Subsection "\s-1CGI\s0.pm field-level options"

.IX Subsection "\s-1EXAMPLE\s0 #1: Using a form to generate email "

.IX Subsection "\s-1EXAMPLE\s0 #2: Appending data to a file"

.IX Header "BUGS"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

